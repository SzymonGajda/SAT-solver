//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"

/********************   FormIff    ********************/
FormIff::FormIff(Formula *p1, Formula *p2)
{
  formula_1 = p1;
  formula_2 = p2;

}

FormIff::FormIff(const FormIff & other)
{
  formula_1 = other.formula_1->clone();
  formula_2 = other.formula_2->clone();

}

FormIff &FormIff::operator=(const FormIff & other)
{
  FormIff tmp(other);
  swap(tmp);
  return *this;
}

void FormIff::swap(FormIff & other)
{
  std::swap(formula_1, other.formula_1);
  std::swap(formula_2, other.formula_2);

}

FormIff::~FormIff()
{
  delete(formula_1);
  delete(formula_2);

}

void FormIff::accept(Visitor *v)
{
  v->visitFormIff(this);
}

FormIff *FormIff::clone() const
{
  return new FormIff(*this);
}

String FormIff::toString() {
    return "FormIff";
}


/********************   FormImplies    ********************/
FormImplies::FormImplies(Formula *p1, Formula *p2)
{
  formula_1 = p1;
  formula_2 = p2;

}

FormImplies::FormImplies(const FormImplies & other)
{
  formula_1 = other.formula_1->clone();
  formula_2 = other.formula_2->clone();

}

FormImplies &FormImplies::operator=(const FormImplies & other)
{
  FormImplies tmp(other);
  swap(tmp);
  return *this;
}

void FormImplies::swap(FormImplies & other)
{
  std::swap(formula_1, other.formula_1);
  std::swap(formula_2, other.formula_2);

}

FormImplies::~FormImplies()
{
  delete(formula_1);
  delete(formula_2);

}

void FormImplies::accept(Visitor *v)
{
  v->visitFormImplies(this);
}

FormImplies *FormImplies::clone() const
{
  return new FormImplies(*this);
}

String FormImplies::toString() {
    return "FormImplies";
}


/********************   FormOr    ********************/
FormOr::FormOr(Formula *p1, Formula *p2)
{
  formula_1 = p1;
  formula_2 = p2;

}

FormOr::FormOr(const FormOr & other)
{
  formula_1 = other.formula_1->clone();
  formula_2 = other.formula_2->clone();

}

FormOr &FormOr::operator=(const FormOr & other)
{
  FormOr tmp(other);
  swap(tmp);
  return *this;
}

void FormOr::swap(FormOr & other)
{
  std::swap(formula_1, other.formula_1);
  std::swap(formula_2, other.formula_2);

}

FormOr::~FormOr()
{
  delete(formula_1);
  delete(formula_2);

}

void FormOr::accept(Visitor *v)
{
  v->visitFormOr(this);
}

FormOr *FormOr::clone() const
{
  return new FormOr(*this);
}

String FormOr::toString() {
    return "FormOr";
}


/********************   FormAnd    ********************/
FormAnd::FormAnd(Formula *p1, Formula *p2)
{
  formula_1 = p1;
  formula_2 = p2;

}

FormAnd::FormAnd(const FormAnd & other)
{
  formula_1 = other.formula_1->clone();
  formula_2 = other.formula_2->clone();

}

FormAnd &FormAnd::operator=(const FormAnd & other)
{
  FormAnd tmp(other);
  swap(tmp);
  return *this;
}

void FormAnd::swap(FormAnd & other)
{
  std::swap(formula_1, other.formula_1);
  std::swap(formula_2, other.formula_2);

}

FormAnd::~FormAnd()
{
  delete(formula_1);
  delete(formula_2);

}

void FormAnd::accept(Visitor *v)
{
  v->visitFormAnd(this);
}

FormAnd *FormAnd::clone() const
{
  return new FormAnd(*this);
}

String FormAnd::toString() {
    return "FormAnd";
}


/********************   FormNot    ********************/
FormNot::FormNot(Formula *p1)
{
  formula_ = p1;

}

FormNot::FormNot(const FormNot & other)
{
  formula_ = other.formula_->clone();

}

FormNot &FormNot::operator=(const FormNot & other)
{
  FormNot tmp(other);
  swap(tmp);
  return *this;
}

void FormNot::swap(FormNot & other)
{
  std::swap(formula_, other.formula_);

}

FormNot::~FormNot()
{
  delete(formula_);

}

void FormNot::accept(Visitor *v)
{
  v->visitFormNot(this);
}

FormNot *FormNot::clone() const
{
  return new FormNot(*this);
}

String FormNot::toString() {
    return "FormNot";
}


/********************   FormVar    ********************/
FormVar::FormVar(String p1)
{
  string_ = p1;

}

FormVar::FormVar(const FormVar & other)
{
  string_ = other.string_;

}

FormVar &FormVar::operator=(const FormVar & other)
{
  FormVar tmp(other);
  swap(tmp);
  return *this;
}

void FormVar::swap(FormVar & other)
{
  std::swap(string_, other.string_);

}

FormVar::~FormVar()
{

}

void FormVar::accept(Visitor *v)
{
  v->visitFormVar(this);
}

FormVar *FormVar::clone() const
{
  return new FormVar(*this);
}

String FormVar::toString() {
    return "FormVar";
}


/********************   FormFalse    ********************/
FormFalse::FormFalse()
{

}

FormFalse::FormFalse(const FormFalse & other)
{

}

FormFalse &FormFalse::operator=(const FormFalse & other)
{
  FormFalse tmp(other);
  swap(tmp);
  return *this;
}

void FormFalse::swap(FormFalse & other)
{

}

FormFalse::~FormFalse()
{

}

void FormFalse::accept(Visitor *v)
{
  v->visitFormFalse(this);
}

FormFalse *FormFalse::clone() const
{
  return new FormFalse(*this);
}

String FormFalse::toString() {
    return "FormFalse";
}


/********************   FormTrue    ********************/
FormTrue::FormTrue()
{

}

FormTrue::FormTrue(const FormTrue & other)
{

}

FormTrue &FormTrue::operator=(const FormTrue & other)
{
  FormTrue tmp(other);
  swap(tmp);
  return *this;
}

void FormTrue::swap(FormTrue & other)
{

}

FormTrue::~FormTrue()
{

}

void FormTrue::accept(Visitor *v)
{
  v->visitFormTrue(this);
}

FormTrue *FormTrue::clone() const
{
  return new FormTrue(*this);
}

String FormTrue::toString() {
    return "FormTrue";
}






